<?xml version="1.0" encoding="ISO-8859-1"?>
  <chapter id="otherclasses">
  <title>
  Selecting a Node in the Search Tree
  </title>
  <section id="comparison">
  <title>CbcCompare - Comparison Methods</title>
  <para>
  The order in which the nodes of the tree are explored is not predetermined and can be influenced by the user.
  CBC provides a abstract base class <classname>CbcCompareBase</classname>
  and several instances which are described in <xref linkend="compareTable"/>.
  </para>
    <table frame="none" id="compareTable">
  <title>Compare Classes Provided</title>
    <tgroup cols="2">
    <thead>
    <row>
    <entry>
    Class name 
    </entry>
    <entry>
    Description
    </entry>
    </row>
    </thead>
    <tbody>
    <row>
      <entry align="left" valign="top">
      <classname>CbcCompareDepth</classname>
      </entry>
      <entry align="left" valign="top">
      This will always choose the node deepest in tree.  It gives minimum
      tree size but may take a long time to find best solution.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcCompareObjective</classname>
      </entry>
      <entry align="left" valign="top">
      This will always choose the node with the best objective value.  This may
      give a very large tree.  It is likely that the first solution found
      will be the best and the search should finish soon after the first solution
      is found.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcCompareDefault</classname>
      </entry>
      <entry align="left" valign="top">
      This is designed to do a mostly depth first search until a solution has
      been found and then use estimates designed to give a slightly better solution.
      If a reasonable number of nodes have been done or a reasonable number of
      solutions found then it will go breadth first (i.e. on objective) unless
      the tree is very large when it will revert to depth first.  Probably
      <classname>CbcCompareUser</classname> described below is better.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcCompareEstimate</classname>
      </entry>
      <entry align="left" valign="top">
      If pseudocosts are being used then they can be used to guess a solution.
      This just uses guessed solution.
      </entry>
    </row>
    </tbody>
  </tgroup>
  </table>
  <para>
  It is relatively simple for an advanced user to create new compare class instances.  This describes how to build a new comparison class and the reasoning behind it. This is <filename>CbcCompareUser.hpp</filename> and <filename>CbcCompareUser.cpp</filename> (this code can be found in the CBC Samples directory, see
  <xref linkend="moreexamples"/>).  The key <classname>CbcCompare</classname> method is <function>bool test(CbcNode* x, CbcNode* y))</function> which returns true if node <parameter>y</parameter> is better than node <parameter>x</parameter>. In this method the user can easily use the following information available from <classname>CbcModel</classname>.
  <table frame="none">
  <title>Information Available from <classname>CbcNode</classname></title>
    <tgroup cols="2">
    <tbody>
    <row>
      <entry align="left" valign="top">
      <function>double objectiveValue() const</function>
      </entry>
      <entry align="left" valign="top">
      Value of objective at that node.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>int numberUnsatisfied() const</function>
      </entry>
      <entry align="left" valign="top">
      Number of unsatisfied integers (assuming branching 
      object is an integer - otherwise might be number of unsatsified sets).
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>int depth() const</function>
      </entry>
      <entry align="left" valign="top">
       Depth of the node in the search tree.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>double guessedObjectiveValue() const</function>
      </entry>
     <entry align="left" valign="top"> 
     If user was setting this (e.g., if using pseudo costs).
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>int way() const</function>
      </entry>
      <entry align="left" valign="top">
       The way which branching would next occur from this node
       (for more advanced use).
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>int variable() const</function>
      </entry>
      <entry align="left" valign="top">
       The branching "variable" (associated with the <classname>CbcBranchingObject</classname> -- for more advanced use).
      </entry>
    </row>
    </tbody>
  </tgroup>
  </table>
</para>

<para>
  There is no information on the state of the tree. If you wanted you could 
  keep a pointer to the <classname>CbcModel</classname> but the way it is meant to work is that 
  <function>newSolution()</function> is called whenever a solution is found and <function>every1000Nodes()</function> is called every 1000 nodes.  When these are called the user can modify the 
  behavior of <function>test()</function>.  Because <classname>CbcNode</classname> has a pointer to the model, the user can also do other things such as changing the maximum time of CBC once a solution has been found (e.g., <function>CbcModel::setMaximumSeconds(double value)</function>). In <filename>CbcCompareUser.cpp</filename> in <filename>COIN/Cbc/Samples</filename> four items of data are used.
</para>
<itemizedlist>
  <listitem>
  <para>
1) The number of solutions found so far 
  </para>
  </listitem>
  <listitem>
  <para>
2) The size of the tree (defined to be the number of active nodes)
  </para>
  </listitem>
  <listitem>
  <para>
3) A weight which is initialized to -1.0
  </para>
  </listitem>
  <listitem>
  <para>
4) A saved value of weight (for when we set weight back to -1.0 for special reason)
  </para>
  </listitem>
</itemizedlist>
<para>
The full code for <function>CbcCompareUser::test()</function> is given below.
</para>
  <example>
  <title>test</title>
  <programlisting>
  <![CDATA[  
// Returns true if y better than x
bool 
CbcCompareUser::test (CbcNode * x, CbcNode * y)
{
  if (weight_==-1.0) {
    // before solution
    if (x->numberUnsatisfied() > y->numberUnsatisfied())
      return true;
    else if (x->numberUnsatisfied() < y->numberUnsatisfied())
      return false;
    else
      return x->depth() < y->depth();
  } else {
    // after solution
    double weight = CoinMax(weight_,0.0);
    return x->objectiveValue()+ weight*x->numberUnsatisfied() > 
      y->objectiveValue() + weight*y->numberUnsatisfied();
  }
}
  ]]>   
  </programlisting>
  </example>
<para>
Initially, <varname>weight</varname>_ is &lt; 0.0 and we are biased towards depth first.  In 
fact, the method prefers <parameter>y</parameter> if <parameter>y</parameter> has fewer unsatisfied variables. In the case of a tie, the method prefers the node with the greater depth in tree.

Once we get a solution <function>newSolution()</function> is called.  If it was a solution 
achieved by branching, <!-- how do can you determine that? --> we work out how much it cost per unsatisfied integer 
variable to go from continuous solution to integer solution.  We then set the weight to aim at a slightly better solution.  From then on the method <function>test()</function> returns true if it looks as if <parameter>y</parameter> will lead to a better solution than <parameter>x</parameter>. This is done by <function>newSolution()</function>.
</para>
  <example>
  <title>newSolution</title>
  <programlisting>
  <![CDATA[  
// This allows method to change behavior as it is called
// after each solution
void 
CbcCompareUser::newSolution(CbcModel * model,
			       double objectiveAtContinuous,
			       int numberInfeasibilitiesAtContinuous) 
{
  if (model->getSolutionCount()==model->getNumberHeuristicSolutions())
    return; // solution was got by rounding so we ignore
  // set to get close to this solution
  double costPerInteger = 
    (model->getObjValue()-objectiveAtContinuous)/
    ((double) numberInfeasibilitiesAtContinuous);
  weight_ = 0.98*costPerInteger;
  saveWeight_=weight_;
  numberSolutions_++;
  if (numberSolutions_>5)
    weight_ =0.0; // this searches on objective
}
  ]]>   
  </programlisting>
  </example>
<para>

But as the search goes on this <!-- what? is "this"? --> may be modified. If a lot of nodes or got a lot of solutions have been genereated, then <varname>weight_</varname> is set to 0.0 so we are doing breadth-first search.  Breadth-first search can lead to an enormous tree. If the tree size is exceeds 10000, then we may desire to go back to a search biased towards depth first. Changing the behaviour done by the method <function>every1000Nodes</function>.
  </para>
  <example>
  <title>newSolution</title>
  <programlisting>
  <![CDATA[  
// This allows method to change behavior 
bool 
CbcCompareUser::every1000Nodes(CbcModel * model, int numberNodes)
{
  if (numberNodes>10000)
    weight_ =0.0; // this searches on objective
  else if (numberNodes==1000&&weight_==-2.0)
    weight_=-1.0; // Go to depth first
  // get size of tree
  treeSize_ = model->tree()->size();
  if (treeSize_>10000) {
    // set weight to reduce size most of time
    if (treeSize_>20000)
      weight_=-1.0;
    else if ((numberNodes%4000)!=0)
      weight_=-1.0;
    else
      weight_=saveWeight_;
  }
  return numberNodes==11000; // resort if first time
}
  ]]>   
  </programlisting>
  </example>
  </section>
</chapter>
<chapter id="hueristicChap">
  <title>
  Using Hueristics in CBC
  </title>
  <section id="heuristics">
  <title>CbcHeuristic - Heuristic Methods</title>
  <para>
  In practice, it is very useful to get a good solution reasonably fast.
  A good bound will greatly reduce the run time and good solutions can satisfy the user
  on very large problems where a complete search is impossible.  Obviously, heuristics are
  problem dependent although some have more general use.
  At present there is only one in CBC itself. Hopefully, the number of heuristics will grow.
  Other hueristics are in the <filename>COIN/Cbc/Samples</filename>
  directory.  A heuristic tries to obtain a solution to the original
  problem so it only needs to consider the original rows and does not have to use the
  current bounds.
  One to use a greedy heuristic designed for use in the miplib problem
  fast0507 will be developed later in this section. <!-- huh? -->
  CBC provides an abstract base class <classname>CbcHeuristic</classname> and a rounding heuristic in CBC.
  </para>
  <para>
  This describes how to build a greedy heuristic for a set covering problem. 
   A more general version is in <filename>CbcHeuristicGreedy.hpp</filename> and
   <filename>CbcHeuristicGreedy.cpp</filename> which can be found in the <filename>COIN/Cbc/Samples</filename> directory, see <xref linkend="moreexamples"/>.

  The heuristic we will code will leave all variables which are at one at this node of the
  tree to that value and will
  initially set all others to zero.  We then sort all variables in order of their cost
  divided by the number of entries in rows which are not yet covered.  We may randomize that
  value a bit so that ties will be broken in different ways on different runs of the heuristic.
  We then choose the best one and set it to one and repeat the exercise. Because this is
  a set covering problem &ge; we are guaranteed to find a solution (not necessarily a
  better one though).  We could
  improve the speed by just redoing those affected but in this text we will keep it simple.
  Also if all elements are 1.0 then we could do faster.
  The key CbcHeuristic method is <function>int&nbsp;solution(double &amp; solutionValue,
                                              double&nbsp;*&nbsp;betterSolution)</function>
  which returns 0 if no solution found and 1 if found when it fills in the objective value
  and primal solution.  The actual code in <filename>CbcHeuristicGreedy.cpp</filename> is
  a little more complicated but this will work and gives the basic idea.  For instance
  the code here assumes all variables are integer.
  The important bit of data is a copy of the matrix (stored by column)
  before any cuts have been made.  The data used are bounds, objective and the matrix
  plus two work arrays. 
  </para>
  <example>
  <title>Data</title>
  <programlisting>
  <![CDATA[  
  OsiSolverInterface * solver = model_->solver(); // Get solver from CbcModel
  const double * columnLower = solver->getColLower(); // Column Bounds
  const double * columnUpper = solver->getColUpper();
  const double * rowLower = solver->getRowLower(); // We know we only need lower bounds
  const double * solution = solver->getColSolution();
  const double * objective = solver->getObjCoefficients(); // In code we also use min/max
  double integerTolerance = model_->getDblParam(CbcModel::CbcIntegerTolerance);
  double primalTolerance;
  solver->getDblParam(OsiPrimalTolerance,primalTolerance);
  int numberRows = originalNumberRows_; // This is number of rows when matrix was passed in
  // Column copy of matrix (before cuts)
  const double * element = matrix_.getElements();
  const int * row = matrix_.getIndices();
  const CoinBigIndex * columnStart = matrix_.getVectorStarts();
  const int * columnLength = matrix_.getVectorLengths();

  // Get solution array for heuristic solution
  int numberColumns = solver->getNumCols();
  double * newSolution = new double [numberColumns];
  // And to sum row activities
  double * rowActivity = new double[numberRows];
  ]]>   
  </programlisting>
  </example>
<para>
Then we initialize newSolution as rounded down solution.
</para>
  <example>
  <title>initialize newSolution</title>
  <programlisting>
  <![CDATA[  
  for (iColumn=0;iColumn<numberColumns;iColumn++) {
    CoinBigIndex j;
    double value = solution[iColumn];
    // Round down integer
    if (fabs(floor(value+0.5)-value)<integerTolerance) 
      value=floor(CoinMax(value+1.0e-3,columnLower[iColumn]));
    // make sure clean
    value = CoinMin(value,columnUpper[iColumn]);
    value = CoinMax(value,columnLower[iColumn]);
    newSolution[iColumn]=value;
    if (value) {
      double cost = direction * objective[iColumn];
      newSolutionValue += value*cost;
      for (j=columnStart[iColumn];
           j<columnStart[iColumn]+columnLength[iColumn];j++) {
        int iRow=row[j];
        rowActivity[iRow] += value*element[j];
      }
    }
  }
  ]]>   
  </programlisting>
  </example>
<para>
Now some row activities will be below their lower bound so
we then find the variable which is cheapest in reducing the sum of
infeasibilities.  We then repeat.  This is a finite process and could be coded
to be faster but this is simplest.
  </para>
  <example>
  <title>Create feasible new solution</title>
  <programlisting>
  <![CDATA[  
  while (true) {
    // Get column with best ratio
    int bestColumn=-1;
    double bestRatio=COIN_DBL_MAX;
    for (int iColumn=0;iColumn<numberColumns;iColumn++) {
      CoinBigIndex j;
      double value = newSolution[iColumn];
      double cost = direction * objective[iColumn];
      // we could use original upper rather than current
      if (value+0.99<columnUpper[iColumn]) {
        double sum=0.0; // Compute how much we will reduce infeasibility by
        for (j=columnStart[iColumn];
             j<columnStart[iColumn]+columnLength[iColumn];j++) {
          int iRow=row[j];
          double gap = rowLower[iRow]-rowActivity[iRow];
          if (gap>1.0e-7) {
            sum += CoinMin(element[j],gap);
          if (element[j]+rowActivity[iRow]<rowLower[iRow]+1.0e-7) {
            sum += element[j];
	  }
	}
        if (sum>0.0) {
	  double ratio = (cost/sum)*(1.0+0.1*CoinDrand48());
	  if (ratio<bestRatio) {
            bestRatio=ratio;
            bestColumn=iColumn;
          }
	}
      }
    }
    if (bestColumn<0)
      break; // we have finished
    // Increase chosen column
    newSolution[bestColumn] += 1.0;
    double cost = direction * objective[bestColumn];
    newSolutionValue += cost;
    for (CoinBigIndex j=columnStart[bestColumn];
         j<columnStart[bestColumn]+columnLength[bestColumn];j++) {
      int iRow = row[j];
      rowActivity[iRow] += element[j];
    }
  }
  ]]>   
  </programlisting>
  </example>
<para>
We have finished so now we need to see if solution is better and doublecheck
we are feasible.
  </para>
  <example>
  <title>Check good solution</title>
  <programlisting>
  <![CDATA[  
  returnCode=0; // 0 means no good solution
  if (newSolutionValue<solutionValue) {
    // check feasible
    memset(rowActivity,0,numberRows*sizeof(double));
    for (iColumn=0;iColumn<numberColumns;iColumn++) {
      CoinBigIndex j;
      double value = newSolution[iColumn];
      if (value) {
	for (j=columnStart[iColumn];
	     j<columnStart[iColumn]+columnLength[iColumn];j++) {
	  int iRow=row[j];
	  rowActivity[iRow] += value*element[j];
	}
      }
    }
    // check was approximately feasible
    bool feasible=true;
    for (iRow=0;iRow<numberRows;iRow++) {
      if(rowActivity[iRow]<rowLower[iRow]) {
	if (rowActivity[iRow]<rowLower[iRow]-10.0*primalTolerance)
	  feasible = false;
      }
    }
    if (feasible) {
      // new solution
      memcpy(betterSolution,newSolution,numberColumns*sizeof(double));
      solutionValue = newSolutionValue;
      // We have good solution
      returnCode=1;
    }
  }
  ]]>   
  </programlisting>
  </example>
  </section>
</chapter>

<chapter id="branchChapter">
  <title>
  Branching
 </title>
  <section id="branching">
  <title>Branching</title>
  <para>
If the user declares variables as integer but does no more, then Cbc will treat them
as simple integer variables.  In many cases the user would like to do some more fine tuning.  This shows how to create integer variables with pseudo costs.  When pseudo costs are given then 
it is assumed that if a variable is at 1.3 then the cost of branching that variable down will be 0.3 times the down pseudo cost and the cost of branching up would be 0.7 times the up pseudo cost.  This can be used both for branching and for choosing a node.
   The full code is in <filename>longthin.cpp</filename>
  (this code can be found in the CBC Samples directory, see
  <xref linkend="moreexamples"/>).  
  The idea is simple for set covering problems.
  Branching up gets us much closer to an integer solution so we want
  to encourage up - so we will branch up if variable value > 0.333333.
  The expected cost of going up obviously depends on the cost of the
  variable so we just choose pseudo costs to reflect that.
  </para>
  <example>
  <title>Pseudo costs</title>
  <programlisting>
  <![CDATA[  
  int iColumn;
  int numberColumns = solver3->getNumCols();
  // do pseudo costs
  CbcObject ** objects = new CbcObject * [numberColumns];
  // Point to objective
  const double * objective = model.getObjCoefficients();
  int numberIntegers=0;
  for (iColumn=0;iColumn<numberColumns;iColumn++) {
    if (solver3->isInteger(iColumn)) {
      double cost = objective[iColumn];
      CbcSimpleIntegerPseudoCost * newObject =
        new CbcSimpleIntegerPseudoCost(&model,numberIntegers,iColumn,
                                       2.0*cost,cost);
      newObject->setMethod(3);
      objects[numberIntegers++]= newObject;
    }
  }
  // Now add in objects (they will replace simple integers)
  model.addObjects(numberIntegers,objects);
  for (iColumn=0;iColumn<numberIntegers;iColumn++)
    delete objects[iColumn];
  delete [] objects;
  ]]>   
  </programlisting>
  </example>
<para>
The actual coding in the example also tries to give more importance to variables with more 
coefficients.  Whether this sort of thing is worthwhile should be the subject of experimentation.
Here is another example which is for crew scheduling problems.  In this case the problem has
few rows but many thousands of variables.  Branching a variable to 1 is very powerful as it
fixes many other variables to zero, but branching to zero is very weak as thousands of variables
can increase from zero.  But in crew scheduling each constraint is a flight leg e.g. JFK to DFW.
From DFW (Dallas) there may be several flights the crew could take next - suppose one flight is 
the 9:30 flight from DFW to LAX (Los Angeles).  Then a binary branch is that the crew arriving 
at DFW either take the 9:30 flight to LAX or they don't.  This follow-on branching does not
fix individual variables but instead divides all the variables with entries in the JFK-DFW 
constraint into two groups - those with entries in the DFW-LAX constraint and those without
entries.
   The full code is in <filename>crew.cpp</filename>
  (this code can be found in the CBC Samples directory, see
  <xref linkend="moreexamples"/>).  In this case we may as well leave the simple integer
variables and we may have to if there are other sorts of constraints.  But we want to 
branch on the follow-on rules first so we use priorities to say that those are the
important ones.
</para>
  <example>
  <title>Follow-on branching</title>
  <programlisting>
  <![CDATA[  
  int iColumn;
  int numberColumns = solver3->getNumCols();
  /* We are going to add a single follow on object but we
     want to give low priority to existing integers 
     As the default priority is 1000 we don't actually need to give
     integer priorities but it is here to show how.
  */
  // Normal integer priorities
  int * priority = new int [numberColumns];
  int numberIntegers=0;
  for (iColumn=0;iColumn<numberColumns;iColumn++) {
    if (solver3->isInteger(iColumn)) {
      priority[numberIntegers++]= 100; // low priority
    }
  }
  /* Second parameter is true if we are adding objects,
     false if integers.  So this does integers */
  model.passInPriorities(priority,false);
  delete [] priority;
  /* Add in objects before we can give priority.
     In this case just one - but this shows general method
  */
  CbcObject ** objects = new CbcObject * [1];
  objects[0]=new CbcFollowOn(&model);
  model.addObjects(1,objects);
  delete objects[0];
  delete [] objects;
  // High priority
  int followPriority=1;
  model.passInPriorities(&followPriority,true);
  ]]>   
  </programlisting>
  </example>
  </section>
</chapter>
<chapter id="SolverChap">
<title>
Advance Use of Solver
</title>
  <section id="solver">
  <title>Advanced Use of Solver</title>
  <para>
  Coin Branch and Cut uses a generic <classname>OsiSolverInterface</classname> and its <function>resolve</function> capability.
  This does not give much flexibility so advanced users can inherit from the interface
  of choice.  This describes such a solver for a long thin problem e.g. fast0507 again.
  As with all these examples it is not guaranteed that this is the fastest way to solve
  any of these problems - they are to illustrate techniques.
   The full code is in <filename>CbcSolver2.hpp</filename> and
   <filename>CbcSolver2.cpp</filename>
  (this code can be found in the CBC Samples directory, see
  <xref linkend="moreexamples"/>).
  <function>initialSolve</function> is called a few times so although we will not gain much
  this is a simpler place to start.  The example derives from <classname>OsiClpSolverInterface</classname> and the code
  is:
  </para>
  <example>
  <title>initialSolve</title>
  <programlisting>
  <![CDATA[  
  // modelPtr_ is of type ClpSimplex *
  modelPtr_->setLogLevel(1); // switch on a bit of printout
  modelPtr_->scaling(0); // We don't want scaling for fast0507
  setBasis(basis_,modelPtr_); // Put basis into ClpSimplex
  // Do long thin by sprint
  ClpSolve options;
  options.setSolveType(ClpSolve::usePrimalorSprint);
  options.setPresolveType(ClpSolve::presolveOff);
  options.setSpecialOption(1,3,15); // Do 15 sprint iterations
  modelPtr_->initialSolve(options); // solve problem
  basis_ = getBasis(modelPtr_); // save basis
  modelPtr_->setLogLevel(0); // switch off printout
  ]]>   
  </programlisting>
  </example>
<para>
The <function>resolve</function> method is more complicated.  The main pieces of data are
a counter <varname>count_</varname>which is incremented each solve and an int array <varname>node_</varname> which stores the last time
a variable was active in a solution.  For the first few times normal dual is called and
<varname>node_</varname> array is updated.
</para>
  <example>
  <title>First few solves</title>
  <programlisting>
  <![CDATA[  
  if (count_<10) {
    OsiClpSolverInterface::resolve(); // Normal resolve
    if (modelPtr_->status()==0) {
      count_++; // feasible - save any nonzero or basic
      const double * solution = modelPtr_->primalColumnSolution();
      for (int i=0;i<numberColumns;i++) {
	if (solution[i]>1.0e-6||modelPtr_->getStatus(i)==ClpSimplex::basic) {
	  node_[i]=CoinMax(count_,node_[i]);
	  howMany_[i]++;
	}
      }
    } else {
      printf("infeasible early on\n");
    }
  }
  ]]>   
  </programlisting>
  </example>
<para>
After the first few solves we only use those which took part in a solution in the last so many
solves.  As fast0507 is a set covering problem we can also take out any rows which are
already covered.
  </para>
  <example>
  <title>Create small problem</title>
  <programlisting>
  <![CDATA[  
    int * whichRow = new int[numberRows]; // Array to say which rows used
    int * whichColumn = new int [numberColumns]; // Array to say which columns used
    int i;
    const double * lower = modelPtr_->columnLower();
    const double * upper = modelPtr_->columnUpper();
    setBasis(basis_,modelPtr_); // Set basis
    int nNewCol=0; // Number of columns in small model
    // Column copy of matrix
    const double * element = modelPtr_->matrix()->getElements();
    const int * row = modelPtr_->matrix()->getIndices();
    const CoinBigIndex * columnStart = modelPtr_->matrix()->getVectorStarts();
    const int * columnLength = modelPtr_->matrix()->getVectorLengths();
    
    int * rowActivity = new int[numberRows]; // Number of columns with entries in each row
    memset(rowActivity,0,numberRows*sizeof(int));
    int * rowActivity2 = new int[numberRows]; // Lower bound on row activity for each row
    memset(rowActivity2,0,numberRows*sizeof(int));
    char * mark = (char *) modelPtr_->dualColumnSolution(); // Get some space to mark columns
    memset(mark,0,numberColumns);
    for (i=0;i<numberColumns;i++) {
      bool choose = (node_[i]>count_-memory_&&node_[i]>0); // Choose if used recently
      // Take if used recently or active in some sense
      if ((choose&&upper[i])
	  ||(modelPtr_->getStatus(i)!=ClpSimplex::atLowerBound&&
             modelPtr_->getStatus(i)!=ClpSimplex::isFixed)
	  ||lower[i]>0.0) {
        mark[i]=1; // mark as used
	whichColumn[nNewCol++]=i; // add to list
        CoinBigIndex j;
        double value = upper[i];
        if (value) {
          for (j=columnStart[i];
               j<columnStart[i]+columnLength[i];j++) {
            int iRow=row[j];
            assert (element[j]==1.0);
            rowActivity[iRow] ++; // This variable can cover this row
          }
          if (lower[i]>0.0) {
            for (j=columnStart[i];
                 j<columnStart[i]+columnLength[i];j++) {
              int iRow=row[j];
              rowActivity2[iRow] ++; // This row redundant
            }
          }
        }
      }
    }
    int nOK=0; // Use to count rows which can be covered
    int nNewRow=0; // Use to make list of rows needed
    for (i=0;i<numberRows;i++) {
      if (rowActivity[i])
        nOK++;
      if (!rowActivity2[i])
        whichRow[nNewRow++]=i; // not satisfied
      else
        modelPtr_->setRowStatus(i,ClpSimplex::basic); // make slack basic
    }
    if (nOK<numberRows) {
      // The variables we have do not cover rows - see if we can find any that do
      for (i=0;i<numberColumns;i++) {
        if (!mark[i]&&upper[i]) {
          CoinBigIndex j;
          int good=0;
          for (j=columnStart[i];
               j<columnStart[i]+columnLength[i];j++) {
            int iRow=row[j];
            if (!rowActivity[iRow]) {
              rowActivity[iRow] ++;
              good++;
            }
          }
          if (good) {
            nOK+=good; // This covers - put in list
            whichColumn[nNewCol++]=i;
          }
        }
      }
    }
    delete [] rowActivity;
    delete [] rowActivity2;
    if (nOK<numberRows) {
      // By inspection the problem is infeasible - no need to solve
      modelPtr_->setProblemStatus(1);
      delete [] whichRow;
      delete [] whichColumn;
      printf("infeasible by inspection\n");
      return;
    }
    // Now make up a small model with the right rows and columns
    ClpSimplex *  temp = new ClpSimplex(modelPtr_,nNewRow,whichRow,nNewCol,whichColumn);
  ]]>   
  </programlisting>
  </example>
<para>
If the variables cover the rows then we know that the problem is feasible (we are not using
cuts).  If the rows
were E rows then this might not be the case and we would have to do more work.  When we have solved
then we see if there are any negative reduced costs and if there are then we have to go to the
full problem and use primal to clean up.
  </para>
  <example>
  <title>Check optimal solution</title>
  <programlisting>
  <![CDATA[  
    temp->setDualObjectiveLimit(1.0e50); // Switch off dual cutoff as problem is restricted
    temp->dual(); // solve
    double * solution = modelPtr_->primalColumnSolution(); // put back solution
    const double * solution2 = temp->primalColumnSolution();
    memset(solution,0,numberColumns*sizeof(double));
    for (i=0;i<nNewCol;i++) {
      int iColumn = whichColumn[i];
      solution[iColumn]=solution2[i];
      modelPtr_->setStatus(iColumn,temp->getStatus(i));
    }
    double * rowSolution = modelPtr_->primalRowSolution();
    const double * rowSolution2 = temp->primalRowSolution();
    double * dual = modelPtr_->dualRowSolution();
    const double * dual2 = temp->dualRowSolution();
    memset(dual,0,numberRows*sizeof(double));
    for (i=0;i<nNewRow;i++) {
      int iRow=whichRow[i];
      modelPtr_->setRowStatus(iRow,temp->getRowStatus(i));
      rowSolution[iRow]=rowSolution2[i];
      dual[iRow]=dual2[i];
    }
    // See if optimal
    double * dj = modelPtr_->dualColumnSolution();
    // get reduced cost for large problem
    // this assumes minimization
    memcpy(dj,modelPtr_->objective(),numberColumns*sizeof(double));
    modelPtr_->transposeTimes(-1.0,dual,dj);
    modelPtr_->setObjectiveValue(temp->objectiveValue());
    modelPtr_->setProblemStatus(0);
    int nBad=0;
      
    for (i=0;i<numberColumns;i++) {
      if (modelPtr_->getStatus(i)==ClpSimplex::atLowerBound
          &&upper[i]>lower[i]&&dj[i]<-1.0e-5)
        nBad++;
    }
    // If necessary claen up with primal (and save some statistics)
    if (nBad) {
      timesBad_++;
      modelPtr_->primal(1);
      iterationsBad_ += modelPtr_->numberIterations();
    }
  ]]>   
  </programlisting>
  </example>
<para>
We then update <varname>node_</varname> array as for the first few solves.  To give some idea of the effect of this
tactic fast0507 has 63,009 variables and the small problem never has more than 4,000 variables.
In just over ten percent of solves did we have to resolve and then the average number of iterations
on full problem was less than 20.
To give another example - again only for illustrative purposes it is possible to do quadratic
mip.  In this case we make <function>resolve</function> the same as 
<function>initialSolve</function>.
   The full code is in <filename>ClpQuadInterface.hpp</filename> and
   <filename>ClpQuadInterface.cpp</filename>
  (this code can be found in the CBC Samples directory, see
  <xref linkend="moreexamples"/>).
  </para>
  <example>
  <title>Solve a quadratic mip</title>
  <programlisting>
  <![CDATA[  
  // save cutoff
  double cutoff = modelPtr_->dualObjectiveLimit();
  modelPtr_->setDualObjectiveLimit(1.0e50);
  modelPtr_->scaling(0);
  modelPtr_->setLogLevel(0);
  // solve with no objective to get feasible solution
  setBasis(basis_,modelPtr_);
  modelPtr_->dual();
  basis_ = getBasis(modelPtr_);
  modelPtr_->setDualObjectiveLimit(cutoff);
  if (modelPtr_->problemStatus()) 
    return; // problem was infeasible 
  // Now pass in quadratic objective
  ClpObjective * saveObjective  = modelPtr_->objectiveAsObject();
  modelPtr_->setObjectivePointer(quadraticObjective_);
  modelPtr_->primal();
  modelPtr_->setDualObjectiveLimit(cutoff);
  if (modelPtr_->objectiveValue()>cutoff)
    modelPtr_->setProblemStatus(1);
  modelPtr_->setObjectivePointer(saveObjective);
  ]]>   
  </programlisting>
  </example>
  </section>
  </chapter>
