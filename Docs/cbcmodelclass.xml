<?xml version="1.0" encoding="ISO-8859-1"?>
  <chapter id="cbcmodelclass">
  <title>
   The CBC Model Class
  </title>
  <section id="hierarchy">
  <title>
  Overview
  </title>
  <para>
  The class that controls CBC is <classname>CbcModel</classname>.  This class is where most
  of the parameter setting is done. The absolute minimum number of actions for <classname>CbcModel</classname> is two:

    <itemizedlist>
    <listitem>
    <simpara>
    <function>CbcModel(OsiSolverInterface &amp; linearSolver)</function> as constructor, and
    </simpara>
    </listitem>
    <listitem>
    <simpara>
    <function>branchAndBound()</function> for solving the problem.    
    </simpara>
    </listitem>
    </itemizedlist>
  </para>
  </section>

  <section id="firstexample">
  <title>
  First Example
  </title>
  <para>
  Below is our first CBC sample program.  This program is short enough to present in full.
  This code can be found in the CBC Samples directory, <filename>COIN/Cbc/Samples</filename>.
  Most of the remaining examples in this Guide will take the form of small code fragments.
  </para>
  <example id="minimum.cpp">
  <title>minimum.cpp</title>
  <programlisting>
  <![CDATA[  
// Copyright (C) 2005, International Business Machines
// Corporation and others.  All Rights Reserved.

#include "CbcModel.hpp"

// Using CLP as the solver
#include "OsiClpSolverInterface.hpp"

int main (int argc, const char *argv[])
{
  OsiClpSolverInterface solver1;

  // Read in example model in MPS file format
  // and assert that it is a clean model
  int numMpsReadErrors = solver1.readMps("../../Mps/Sample/p0033.mps","");
  assert(numMpsReadErrors==0);

  // Pass the solver (with the problem data) to CbcModel 
  CbcModel model(solver1);

  // Do complete search
  model.branchAndBound();

  /* Print the solution.  CbcModel clones solver so we
     need to get current copy from the CbcModel */
  int numberColumns = model.solver()->getNumCols();
    
  const double * solution = model.solver()->getColSolution();
    
  for (int iColumn=0;iColumn<numberColumns;iColumn++) {
    double value=solution[iColumn];
    if (fabs(value)>1.0e-7&&model.solver()->isInteger(iColumn)) 
      printf("%d has value %g\n",iColumn,value);
   }
  return 0;
}    
  ]]>   
  </programlisting>
  </example>
  <!-- Clone comment  needs more explaination. What info is safe? When do you need to do a refresh?? -->
  <!-- printf vs cout  -->

  <para>
  The sample program <xref linkend="minimum.cpp"/> creates a <classname>OsiClpSolverInterface</classname> solver interface, and reads an MPS file. If there are no errors, the program passes the solver to <classname>CbcModel</classname>
  which solves it using the branch-and-bound algorithm.  The part of the program which solves the problem
  is very small (one line!) but before that one line, the LP solver had to be created and populated with data and
  after that one line the results were printed out. 
 </para>
</section>

<section id="osiAndCbc">
<title>
The Relationship Between OSI and CBC
</title>
<para> 
 Example <xref linkend="minimum.cpp"/> illustrates the dependency of CBC on  
  the <classname>OsiSolverInterface</classname> class. The constructor of <classname>CbcModel</classname> takes a pointer to an <classname>OsiSolverInterface</classname> (i.e., a solver). The <classname>CbcModel</classname> clones the solver, and uses its own instance of the solver. The <classname>CbcModel</classname>'s solver and the original solver (e.g., <varname>sovler1</varname>) are not in sync unless the user synchronizes them. The user can always access the <classname>CbcModel</classname>'s solver through the <function>model()</function> method.  To synchronize the orignal solver, explicitly refreshing it, e.g.,  
 <programlisting>
  solver1 = model.solver();
</programlisting>

For convenience, many of the OSI method's to access problem data have identical method names in  <classname>CbcModel</classname>. (It's just more convenient to type <function>model.getNumCols()</function> rather than <function>model.solver()->getNumCols()</function>). While the method names may be identical, sometimes the values they return are not, e.g., <function>getColSolution()</function>. <classname>CbcModel</classname> refreshes its solver at certain logical points. For instance, the OSI method<function>getColSolution()</function> will contain the best solution so far, while the <classname>CbcModel</classname> method may not. In this case, it is safer to use <function>CbcModel::bestSolution()</function>. 
</para>
<para>
All the OSI methods used in <filename>minimum.cpp</filename> have equivalent methods in <classname>CbcModel</classname>. But there are some OSI methods which are not present in CBC. For example, if  the program produced a lot of undesired output, one might add the line 
</para>
<programlisting>
  model.solver()->setHintParam(OsiDoReducePrint,true,OsiHintTry); 
</programlisting>
<para> 
  <!-- model.solver() returns an OSISolverInterface? -->
  to reduce the output. There is no <function>model.setHintParam(OsiDoReducePrint,true,OsiHintTry)</function>.
  </para>
  </section>

  <section id="gettingsolution">
  <title>
  Getting Solution Information Using <classname>CbcModel</classname> Methods
  </title>
  <para>
  The OSI way to check for optimality is to call <function>model.isProvenOptimal()</function>.  Also
  available are <function>isProvenInfeasible()</function>,
  <function>isSolutionLimitReached()</function>,
  <function>isNodeLimitReached()</function> or the feared
  <function>isAbandoned()</function>. You can also pick up
  <function>int&nbsp;status()</function> which returns 0 if finished,
   1 if stopped by user and 2 if difficulties. (Note: a status of 0 is returned, even if the model is proved
   infeasible.)
  </para>
  <para>
  Similarly, solution values can be accessed via OSI methods.  The OSI methods pick up
  the current solution in the <classname>CBCModel</classname>.  The current solution will match the best solution found so far if called after <function>branchAndBound()</function> and if a solution was found. 
  </para>
  <table frame="none">
  <title>
  Methods for Getting Solution Information from OSI 
  </title>
  <tgroup cols="2">
  <thead>
    <row>
      <entry>
      Purpose
      </entry>
      <entry>
      Name
      </entry>
      <entry>
      Notes
      </entry>
    </row>
  </thead>
  <tbody>
    <row>
      <entry align="left" valign="top">
      Primal column solution
      </entry>
      <entry align="left" valign="top">
      <function>const double * getColSolution()</function>
      </entry>
      <entry align="left" valign="top">
      The OSI version will return  best solution unless none has been found. It is safer to use <classname>CbcModel</classname> version, <function>CbcModel::bestSolution()</function>
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      Dual row solution
      </entry>
      <entry align="left" valign="top">
      <function>const double * getRowPrice()</function>
      </entry>
      <entry align="left" valign="top">
      Identical <classname>CbcModel</classname> version available, <function>CbcModel::getRowPrice()</function>.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      Primal row solution
      </entry>
      <entry align="left" valign="top">
      <function>const double * getRowActivity()</function>
      </entry>
      <entry align="left" valign="top">
      Identical <classname>CbcModel</classname> version available, <function>CbcModel::getRowActivity()</function>.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      Dual column solution
      </entry>
      <entry align="left" valign="top">
      <function>const double * getReducedCost()</function>
      </entry>
     <entry align="left" valign="top">
      Identical <classname>CbcModel</classname> version available, <function>CbcModel::gtReducedCost()</function>.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      Number of rows in model
      </entry>
      <entry align="left" valign="top">
      <function>int getNumRows()</function>
      </entry>
      <entry align="left" valign="top">
      Identical <classname>CbcModel</classname> version available, <function>CbcModel::getNumRows()</function>, but note that the number of rows may change due to cuts. 
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      Number of columns in model
      </entry>
      <entry align="left" valign="top">
      <function>int getNumCols()</function>
      </entry>
      <entry align="left" valign="top">
      Identical <classname>CbcModel</classname> version available, <function>CbcModel::getNumCols()</function>.
      </entry>
    </row>
  </tbody>
  </tgroup>
  </table>
  </section>

  <section id="setsandgets">
  <title>Useful Set and Get Methods in <classname>CbcModel</classname></title>
  <table frame="none">
  <title>Useful Set and Get Methods in <classname>CbcModel</classname></title>
    <tgroup cols="2">
    <thead>
    <row>
    <entry>
    Method(s)
    </entry>
    <entry>
    Description
    </entry>
    </row>
    </thead>
    <tbody>
    <row>
      <entry align="left" valign="top">
      <function>bool&nbsp;setMaximumNodes(int value)</function><sbr/>
      <function>int&nbsp;getMaximumNodes() const</function><sbr/>
      <function>bool&nbsp;setMaximumSeconds(double value)</function><sbr/>

      <function>double&nbsp;getMaximumSeconds()</function><sbr/>
      <function>bool&nbsp;setMaximumSolutions(double value)</function><sbr/>
      <function>double&nbsp;getMaximumSolutions() const</function>
      </entry>
      <entry align="left" valign="top">
      These methods tell CBC to stop after a given number of nodes or
      seconds or solutions (and returns these values).
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>bool&nbsp;setIntegerTolerance(double value) const</function><sbr/>
      <function>double&nbsp;getIntegerTolerance() const</function>
      </entry>
      <entry align="left" valign="top">
      An integer variable
      is deemed to be at an integral value if it is no further than this tolerance 
      away. 
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>bool&nbsp;setAllowableGap(double value)</function><sbr/>
      <function>double&nbsp;getAllowableGap() const</function><sbr/>
      <function>bool&nbsp;setAllowablePercentageGap(double value)</function><sbr/>
      <function>double&nbsp;getAllowablePercentageGap() const</function><sbr/>
      <function>bool&nbsp;setAllowableFractionGap(double value)</function><sbr/>
      <function>double&nbsp;getAllowableFractionGap() const</function><sbr/>
      </entry>
      <entry align="left" valign="top">
      <classname>CbcModel</classname> returns if the gap between the best known solution and the best
      possible solution is less than this (or as a percentage or fraction).
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>void&nbsp;setNumberStrong(double value) </function><sbr/>
      <function>int&nbsp;numberStrong() const </function>
      </entry>
      <entry align="left" valign="top">
      Get or set the maximum number of candidates at a node to
      be evaluated for strong branching.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>void&nbsp;setPrintFrequency(int value) </function><sbr/>
      <function>int&nbsp;printFrequency() const</function>
      </entry>
      <entry align="left" valign="top">
      Controls the number of nodes evaluated between status prints.
      Print frequency has very slight overhead if small.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>int&nbsp;getNodeCount() const</function>
      </entry>
      <entry align="left" valign="top">
      Returns number of nodes search took
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>int&nbsp;numberRowsAtContinuous() const</function>
      </entry>
      <entry align="left" valign="top">
      Returns number of rows at continuous
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>int &nbsp;numberIntegers() const</function><sbr/>
      <function>const int&nbsp;*&nbsp;integerVariable() const</function>
      </entry>
      <entry align="left" valign="top">
      Returns number of integers and an array giving which ones
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>bool&nbsp;isBinary(int colIndex) const</function><sbr/>
      <function>bool&nbsp;isContinuous(int colIndex) const</function><sbr/>
      <function>bool&nbsp;isInteger(int colIndex) const</function>
      </entry>
      <entry align="left" valign="top">
      Returns information on a variable.  You can use OSI methods
      to set these attributes (before handing to <classname>CbcModel</classname>)
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>double&nbsp;getObjValue() const</function>
      </entry>
      <entry align="left" valign="top">
      This method returns the best objective value so far.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>double&nbsp;getCurrentObjValue() const</function>
      </entry>
      <entry align="left" valign="top">
      This method returns the current objective value.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>const&nbsp;double&nbsp;*&nbsp;getObjCoefficients() const</function><sbr/>
       </entry>
      <entry align="left" valign="top">
      This method return the objective coefficients.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>const&nbsp;double&nbsp;*&nbsp;getRowLower() const</function><sbr/>
       <function>const&nbsp;double&nbsp;*&nbsp;getRowUpper() const</function><sbr/>
       <function>const&nbsp;double&nbsp;*&nbsp;getColLower() const</function><sbr/>
       <function>const&nbsp;double&nbsp;*&nbsp;getColUpper() const</function><sbr/>
       </entry>
      <entry align="left" valign="top">
      These methods give lower and upper bounds on row and column activities.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>const&nbsp;CoinPackMatrix&nbsp;*&nbsp;getMatrixByRow() const</function>
      </entry>
      <entry align="left" valign="top">
      This method returns a pointer to a row copy of matrix 
      <classname>CoinPackedMatrix</classname> which can be further examined.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>const CoinPackMatrix * getMatrixByCol() const</function>
      </entry>
      <entry align="left" valign="top">
      This method returns a pointer to a column copy of matrix 
      <classname>CoinPackedMatrix</classname> which can be further examined.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
    <function>CoinBigIndex&nbsp;getNumElements() const</function> 
     <footnote> 
     <para> 
	<type>CoinBigIndex</type> is a <function>typedef</function> which in 
	most cases is the same as <type>int</type>. 
	</para> 
    </footnote> 
      </entry>
      <entry align="left" valign="top">
      Returns the number of elements in the problem matrix.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>void setObjSense(double&nbsp;value)</function><sbr/>
      <function>double getObjSense() const</function> 
      </entry>
      <entry align="left" valign="top">
      These methods set and get the objective sense.  The parameter
      <parameter>value</parameter> should be +1 to minimize and -1 to maximize.
      </entry>
    </row>
    </tbody>
  </tgroup>
  </table>
  </section>
  <section id="majormethods">
  <title>
  Impacting the Solution Process
  </title>
  <para>
  The methods in <xref linkend="majorMethods"/> can have a major impact on CBC's search.. A brief description is given in the table, along with main parameters. ( The description here may not give all parameters if they are exotic.) The remainder of this documents describes some of the common usages of these methods.
  </para>
  <table frame="none" id="majorMethods">
  <title>Major Methods</title>
    <tgroup cols="2">
    <thead>
    <row>
    <entry>
    Method(s)
    </entry>
    <entry>
    Description
    </entry>
    </row>
    </thead>
    <tbody>
    <row>
      <entry align="left" valign="top">
      <function>passInPriorities(const int * priorities, bool ifNotSimpleIntegers,
			int defaultValue=1000)</function>
      </entry>
      <entry align="left" valign="top">
      Normally this is a list of priorities (1 being highest) and the other
      <parameter>ifNotSimpleIntegers</parameter> being false which set priorities for all integer
      variables.  If two variables are unsatisfied and one has a higher priority
      then it is always preferred whatever its value.  This can be very powerful
      but also see PseudoCosts in <classname>CbcObject</classname> discussion.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>addCutGenerator(CglCutGenerator *,int howOften, const char * name)</function>
      </entry>
      <entry align="left" valign="top">
      This is used to add a cut generator to <classname>CbcModel</classname>.  Any cut generator in CGL can be used. If <parameter>howOften</parameter> &gt; 0 then <parameter>name</parameter> will be called at root node and again every <parameter>howOften</parameter> nodes. There is an option to override and to call <parameter>name</parameter> depth 0,k,2k, etc.  If <parameter>howOften</parameter> = -1 then the code determines how effective <parameter>name</parameter>is at root node and dynamically sets <parameter>howOften</parameter>. If <parameter>howOften</parameter> = -99 then <parameter>name></parameter> is just used at root node.
      There is also a redundant <parameter>howOften</parameter> = -100 setting which switches <parameter>name</parameter> off. This parameter setting is useful for testing.  For usage see <filename>sample2.cpp</filename> in the <filename>COIN/Cbc/Samples</filename> directory <xref linkend="moreexamples"/> which uses the most common cut generators.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>addHeuristic(CbcHeuristic *)</function>
      </entry>
      <entry align="left" valign="top">
      This adds one heuristic to <classname>CbcModel</classname>.See the section on <classname>CbcHeuristic</classname>  to obtain
      a list of available heuristics and a guide as to building new ones.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>addObjects(int&nbsp;number,CbcObject&nbsp;**&nbsp;objects) </function>
      </entry>
      <entry align="left" valign="top">
      This adds members of the base class <classname>CbcObject</classname> to <classname>CbcModel</classname>.  See the section
      on <classname>CbcObject</classname> for detailed nformation.  The <parameter>objects</parameter> are cloned by the code so the
      user should delete them after the call to <function>addObjects</function>.  There are two 
      main cases.  The first is when the originally created objects are left and
      new ones added (maybe with a higher priority);  this might be used when
      simple integer objects exist and Special Ordered Sets of type 1 are going
      to be added, which while not necessary will give extra power in branching.
      The second case is when the old ones are being deleted.  
      For usage see <filename>sos.cpp</filename> in the <filename>COIN/Cbc/Samples</filename> directory <xref linkend="moreexamples"/>.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>CglPreProcess::preProcess(OsiSolverInterface &amp;)</function>
      </entry>
      <entry align="left" valign="top">
      This is not really part of CBC and can be used by other mixed integer
      solvers but it can be a useful tool.  It tries to fix variables and 
      strengthen coefficients and also do a normal presolve.  Owing to the 
      odd nature of integer programming it may not always reduce the time
      taken but is definitely worth trying.  For an example of using
      <function>CglPreProcess()</function> (and <function>CglPostProcess()</function>) see <filename>sample2.cpp</filename> in the CBC Samples 
      directory <xref linkend="moreexamples"/>.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <function>setNodeComparison(CbcCompareBase&nbsp;*)</function>
      </entry>
      <entry align="left" valign="top">
       This is used to invoke a non-default node comparisons
       in determining the next node on tree to explore. The order a tree is explored 
       can make a large difference in runtime. Specialized comparisons are easy to implement.
       See the section on <classname>CbcCompare</classname>.
      </entry>
    </row>
    </tbody>
  </tgroup>
  </table>
  </section>

<section id="mostAndLeastUsefulClasses">
 <title>
  Most (and Least) Useful Classes Used by CBC
</title>
<para>
<classname>CbcModel</classname> uses other classes in CBC, some of which are virtual and may have multiple instances. Not all classes are created equal. The two tables below list the classes within <classname>CbcModel</classname> that are of most interest and of least interest. 
</para>
    <table frame="none">
  <title>Classes Used by CbcModel - Most Useful</title>
    <tgroup cols="3">
    <thead>
    <row>
    <entry>
    Class name 
    </entry>
    <entry>
    Description
    </entry>
    <entry>
    Notes
    </entry>
    </row>
    </thead>
    <tbody>
    <row>
      <entry align="left" valign="top">
      <classname>CbcCompareBase</classname>
      </entry>
      <entry align="left" valign="top">
      Controls which node on tree is selected
      </entry>
      <entry align="left" valign="top">
      The default is <classname>CbcCompareDefault</classname>. Other comparison classes in <filename>CbcCompareActual.hpp</filename> include
      <classname>CbcCompareDepth</classname> and <classname>CbcCompareObjective</classname>. It is very easy for user to
      experiment with different comparisons.
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcCutGenerator</classname>
      </entry>
      <entry align="left" valign="top">
      A wrapper for <classname>CglCutGenerator</classname> with additional data to control when the cut generator is used.
      </entry>
      <entry align="left" valign="top">
      Other than knowing how to add a cut generator to <classname>CbcModel</classname>, there is not much the average user needs to know about this class. <!-- what's the default? -->
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcHeuristic</classname>
      </entry>
      <entry align="left" valign="top">
      Heuristic that attempts to generate valid solutions
      </entry>
      <entry align="left" valign="top">
      Users can get a lot of value out of coding specialized heuristics.  There can be
      as many different heuristics as you like. <!-- What's the default? -->
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcObject</classname>
      </entry>
      <entry align="left" valign="top">
      Defines what it means for a variable to be satisfied.
      </entry>
      <entry align="left" valign="top">
      Virtual class. The branching model used in CBC is based on the idea of an "object". An object has (i) feasible region, (ii) can be evaluated for infeaibility, (iii) can be branched on, e.g., a method of generating a branching object, which defines an up branch and a down branch and (iv) allows comparsion of the effect of branching. Instances include simple integer, simple integer with pseudocosts, SOS (type 1 and 2), and lotsizing (see CbcBranch....hpp). 
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>OsiSolverInterface</classname>
      </entry>
      <entry align="left" valign="top">
      Defines the LP solver being used and the LP model. Normally
      a pointer to the desired <classname>OsiSolverInteface</classname> is passed to <classname>CbcModel</classname> before branch and cut.
      </entry>
      <entry align="left" valign="top">
      Virtual class. The user instantiates the solver interface of their choice, e.g., 
      <classname>OsiClpSolverInterface</classname>.
      </entry>
    </row>
    </tbody>
  </tgroup>
  </table>

There is not much about the classes listed in <xref linkend="least"/> that the average user needs to know about. 
    <table frame="none" id="least">
  <title>Classes Used by CbcModel - Least Useful</title>
    <tgroup cols="3">
    <thead>
    <row>
    <entry>
    Class name 
    </entry>
    <entry>
    Description
    </entry>
    <entry>
    Notes
    </entry>
    </row>
    </thead>
    <tbody>
    <row>
      <entry align="left" valign="top">
      <classname>CbcBranchDecision</classname>
      </entry>
      <entry align="left" valign="top">
      Used in choosing which variable to branch on, however, most of 
      the work is done by the definitions in <classname>CbcObject</classname>.
      </entry>
      <entry align="left" valign="top">
      Defaults to <classname>CbcBranchDefaultDecision</classname>. 
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcCountRowCut</classname>
      </entry>
      <entry align="left" valign="top">
      Interface to <classname>OsiRowCut</classname>. It counts the usage so cuts can gracefully vanish.
      </entry>
      <entry align="left" valign="top">
      See <classname>OsiRowCut</classname> for more details. <!-- Default? -->
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcNode</classname>
      </entry>
      <entry align="left" valign="top">
      Controls which variable/entity is selected to be branch on.
      </entry>
      <entry align="left" valign="top">
      Controlled via <classname>CbcModel</classname> parameters.  <!-- Default? -->
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcNodeInfo</classname>
      </entry>
      <entry align="left" valign="top">
      Contains data on bounds, basis, etc. for one node of the search tree.
      </entry>
      <entry align="left" valign="top">
      Header is located in <filename>CbcNode.hpp</filename>. <!-- Defaults? -->
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CbcTree</classname>
      </entry>
      <entry align="left" valign="top">
      Defines how the search tree is stored.
      </entry>
      <entry align="left" valign="top">
      This class can be changed but it is not likely to be modified.<!-- Defaults? -->
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CoinMessageHandler</classname>
      </entry>
      <entry align="left" valign="top">
      Deals with message handling
      </entry>
      <entry align="left" valign="top">
      The user can inherit from <classname>CoinMessageHandler</classname> to specialize message handling.  
      <!-- Defaults? -->
      </entry>
    </row>
    <row>
      <entry align="left" valign="top">
      <classname>CoinWarmStartBasis</classname>
      </entry>
      <entry align="left" valign="top">
      Basis representation to be used by solver
      </entry>
      <entry align="left" valign="top">
      <!-- Defaults? -->
      </entry>
    </row>
    </tbody>
  </tgroup>
  </table>
</section>

  </chapter>
